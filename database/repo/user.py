import asyncio
import datetime
from typing import Optional, Any, Coroutine

from sqlalchemy import select
from sqlalchemy.orm import selectinload

from database import User
from database.models import User, UserProfile, Base
from sqlalchemy.ext.asyncio import AsyncSession

from loguru import logger


async def create_user(
    session: AsyncSession,
    name: str,
    email: Optional[str] = None,
    password_hash: Optional[str] = None,
    bio: Optional[str] = None,
    avatar_url: Optional[str] = None,
    website: Optional[str] = None,
    location: Optional[str] = None,
) -> Optional[User]:
    """
    Creates a new user and their associated profile.

    Args:
        session: The SQLAlchemy asynchronous session.
        name: The unique name for the new user.
        password_hash: The hashed password for the user (optional).
        bio: User's biography (optional).
        avatar_url: URL to the user's avatar image (optional).
        website: User's personal website URL (optional).
        location: User's geographical location (optional).

    Returns:
        The created User object if successful, None if a user with the name already exists.
    """
    # async with session.begin():
    # Check if a user with the given name already exists
    existing_user_stmt = select(User).where(User.name == name)
    existing_user_result = await session.execute(existing_user_stmt)
    if existing_user_result.scalar_one_or_none():
        logger.warning(f"Error: User with name '{name}' already exists. Cannot create.")
        return None

    # Create the User object
    user = User(
        name=name,
        password_hash=password_hash,
        email=email,
    )
    session.add(user)

    # Flush the session to get the user.id before creating the profile,
    # especially important if user.id is auto-generated by the database.
    # SQLAlchemy's relationship handling often makes this implicit,
    # but explicit flush ensures the ID is available.
    await session.flush()

    # Create the UserProfile object and link it to the user
    user_profile = UserProfile(
        user_id=user.id, # user.id is now available after flush
        bio=bio,
        avatar_url=avatar_url,
        website=website,
        location=location,
    )
    # Link the profile to the user object via the relationship
    user.profile = user_profile
    session.add(user_profile) # Add the profile to the session

    # The transaction is committed automatically by session.begin() on successful exit
    logger.success(f"User '{user.name}' created successfully with ID: {user.id}")
    return user

async def get_user(
    session: AsyncSession,
    user_id: Optional[int] = None,
    name: Optional[str] = None
) -> Optional[User]:
    """
    Retrieves a user by ID or name, eagerly loading their profile.

    Args:
        session: The SQLAlchemy asynchronous session.
        user_id: The ID of the user to retrieve (optional).
        name: The name of the user to retrieve (optional).

    Returns:
        The User object if found, otherwise None.
    Raises:
        ValueError: If neither user_id nor name is provided.
    """
    if not user_id and not name:
        raise ValueError("Either user_id or name must be provided to get a user.")

    # Build the query to select a User and eagerly load its profile
    # selectinload is efficient for one-to-one relationships when you expect to access the profile
    # async with session.begin():
    stmt = select(User).options(selectinload(User.profile))

    if user_id:
        stmt = stmt.where(User.id == user_id)
    elif name:
        stmt = stmt.where(User.name == name)

    result = await session.execute(stmt)
    user = result.scalar_one_or_none() # Get a single result or None

    if user:
        logger.success(f"User found: {user.name} (ID: {user.id})")
    else:
        logger.warning(f"User not found with ID: {user_id} or Name: '{name}'")
    return user

async def update_user(
    session: AsyncSession,
    user_id: int,
    name: Optional[str] = None,
    password_hash: Optional[str] = None,
    email: Optional[str] = None,
    bio: Optional[str] = None,
    avatar_url: Optional[str] = None,
    website: Optional[str] = None,
    location: Optional[str] = None,
) -> type[User] | None:
    """
    Updates an existing user's information and their associated profile.

    Args:
        session: The SQLAlchemy asynchronous session.
        user_id: The ID of the user to update.
        name: New name for the user (optional).
        password_hash: New hashed password for the user (optional).
        email: New email for the user (optional).
        bio: New biography for the user's profile (optional).
        avatar_url: New avatar URL for the user's profile (optional).
        website: New website URL for the user's profile (optional).
        location: New location for the user's profile (optional).

    Returns:
        The updated User object if successful, None if the user is not found
        or if the new name conflicts with an existing user.
    """

    # async with session.begin():
    # Retrieve the user and eagerly load their profile for updates
    user = await session.get(User, user_id, options=[selectinload(User.profile)])

    if not user:
        logger.error(f"Error: User with ID {user_id} not found. No update performed.")
        return None

    # Update User fields if provided
    if name is not None and name != user.name:
        # Check if the new name already exists for another user
        existing_user_stmt = select(User).where(User.name == name)
        existing_user_result = await session.execute(existing_user_stmt)
        if existing_user_result.scalar_one_or_none():
            logger.error(f"Error: Cannot update name. User with name '{name}' already exists.")
            return None
        user.name = name
        user.updated_at = datetime.datetime.now(datetime.UTC) # Manually update timestamp if not auto-handled

    if email is not None and email != user.email:
        user.email = email
        user.updated_at = datetime.datetime.now(datetime.UTC)

    if password_hash is not None:
        user.password_hash = password_hash
        user.updated_at = datetime.datetime.now(datetime.UTC)

    # Update UserProfile fields or create a new profile if it doesn't exist
    if user.profile:
        # Update existing profile
        if bio is not None:
            user.profile.bio = bio
        if avatar_url is not None:
            user.profile.avatar_url = avatar_url
        if website is not None:
            user.profile.website = website
        if location is not None:
            user.profile.location = location
    else:
        # If no profile exists, but profile data is provided, create one
        if any(arg is not None for arg in [bio, avatar_url, website, location]):
            logger.info(f"Creating new profile for user ID {user_id}.")
            new_profile = UserProfile(
                user_id=user.id,
                bio=bio,
                avatar_url=avatar_url,
                website=website,
                location=location,
            )
            user.profile = new_profile # Link new profile to user
            session.add(new_profile) # Add new profile to session

    # The transaction is committed automatically by session.begin() on successful exit
    logger.success(f"User '{user.name}' (ID: {user.id}) updated successfully.")
    return user

